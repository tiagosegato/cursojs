<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Padrões de Desenvolvimento de Software</title>
    <style>
        :root {
            --primary-color: #4682A0; /* Azul para destaque */
            --secondary-color: #343746; /* Cinza escuro */
            --accent-color: #4682A0; /* Azul para destaque */
            --text-color: #333;
            --light-text: #f8f9fa;
            --background-color: #ffffff;
            --code-background: #f1f1f1;
            --header-color: #4682A0; /* Azul para cabeçalhos */
            --footer-color: #4682A0; /* Azul para rodapés */
        }
        
        body {
            font-family: 'Avenir', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .slide {
            display: none;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            width: 100%;
        }
        
        .slide.active {
            display: block;
        }
        
        .slide-content {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .slide-header {
            background-color: var(--header-color);
            padding: 1rem 2rem;
            border-bottom: 5px solid var(--secondary-color);
            width: 100%;
            box-sizing: border-box;
        }
        
        .slide-body {
            flex: 1;
            padding: 2rem;
            background-color: white;
            overflow-y: auto;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            padding-bottom: 4rem; /* Espaço extra para evitar sobreposição com os botões */
        }
        
        .slide-footer {
            background-color: var(--footer-color);
            padding: 0.5rem 2rem;
            border-top: 5px solid var(--secondary-color);
            width: 100%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .slide-number {
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        .logo-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .js-logo {
            background-color: var(--accent-color);
            color: var(--secondary-color);
            font-weight: bold;
            font-size: 2rem;
            padding: 0.5rem;
            width: 60px;
            height: 60px;
            text-align: center;
            line-height: 60px;
        }
        
        .bfd-logo {
            height: 60px;
        }
        
        h1 {
            color: var(--secondary-color);
            margin-top: 0;
            font-size: 2.5rem;
            font-family: 'Advent Pro', sans-serif;
        }
        
        h2 {
            color: var(--secondary-color);
            font-size: 1.8rem;
            margin: 0;
            font-family: 'Advent Pro', sans-serif;
        }
        
        h3 {
            color: var(--accent-color);
            font-size: 1.5rem;
            font-family: 'Advent Pro', sans-serif;
        }
        
        ul, ol {
            margin-left: 1.5rem;
        }
        
        li {
            margin-bottom: 0.5rem;
        }
        
        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--code-background);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        
        pre {
            background-color: var(--code-background);
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.9rem;
        }
        
        blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 1rem;
            margin-left: 0;
            font-style: italic;
            color: #555;
        }
        
        .controls {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        button {
            background-color: var(--secondary-color);
            color: var(--primary-color);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        button:hover {
            background-color: var(--accent-color);
        }
        
        .two-column {
            display: flex;
            gap: 2rem;
        }
        
        .column {
            flex: 1;
        }
        
        .code-block {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--code-background);
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 1rem;
            white-space: pre;
        }
        
        .cover-slide .slide-content {
            background-color: white;
            color: var(--secondary-color);
        }
        
        .cover-slide .slide-header {
            background-color: var(--primary-color);
            padding: 2rem;
            text-align: center;
        }
        
        .cover-slide .slide-body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }
        
        .cover-slide h1 {
            color: var(--secondary-color);
            font-size: 3.5rem;
            margin-bottom: 1rem;
        }
        
        .cover-slide h3 {
            color: var(--secondary-color);
            font-weight: normal;
            margin-bottom: 2rem;
        }
        
        .cover-slide h4 {
            color: var(--accent-color);
            font-style: italic;
        }
        
        .cover-logos {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 2rem;
        }
        
        .cover-left {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .cover-right {
            display: flex;
            align-items: center;
        }
        
        @media print {
            .slide {
                display: block;
                page-break-after: always;
                height: auto;
            }
            
            .controls, .slide-number {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Slide 1: Capa -->
    <div class="slide cover-slide active" id="slide-1">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <div class="js-logo">JS</div>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <div class="cover-left">
                    <h3>Formação BackEnd</h3>
                    <h1>Padrões de Desenvolvimento de Software</h1>
                    <h4>Módulo: JavaScript Backend</h4>
                    <p>Prof. Tiago Segato</p>
                </div>
                <div class="cover-right">
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" height="200">
                </div>
            </div>
            <div class="slide-footer">
                <div class="slide-number">1</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 2: Visão Geral da Aula -->
    <div class="slide" id="slide-2">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Visão Geral da Aula</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>Nesta aula, exploraremos os conceitos fundamentais dos Padrões de Desenvolvimento de Software, focando em sua importância, na arquitetura MVC e na documentação técnica essencial com UML.</p>
                <h3>Tópicos Abordados:</h3>
                <ul>
                    <li>Introdução a Padrões de Desenvolvimento de Software</li>
                    <li>Princípios SOLID completos (S, O, L, I, D)</li>
                    <li>Arquitetura MVC aplicada ao backend</li>
                    <li>Documentação técnica essencial (Diagrama de Caso de Uso, Diagrama de Classes, Diagrama de Sequências)</li>
                </ul>
                <blockquote>"Padrões de desenvolvimento são soluções comprovadas para problemas comuns no design de software."</blockquote>
            </div>
            <div class="slide-footer">
                <div class="slide-number">2</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 3: Introdução a Padrões de Desenvolvimento de Software -->
    <div class="slide" id="slide-3">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Introdução a Padrões de Desenvolvimento de Software</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>Padrões de desenvolvimento de software são soluções reutilizáveis para problemas comuns que surgem durante o design de software. Eles são categorizados principalmente em padrões arquiteturais e padrões de projeto.</p>
                <h3>O que são Padrões de Desenvolvimento?</h3>
                <ul>
                    <li><strong>Padrões Arquiteturais:</strong> São modelos de alto nível que definem a estrutura geral de um sistema de software. Eles abordam questões como a organização dos componentes, a comunicação entre eles e a distribuição de responsabilidades. Exemplo: MVC (Model-View-Controller).</li>
                    <li><strong>Padrões de Projeto (Design Patterns):</strong> São soluções de baixo nível para problemas específicos de design de classes e objetos. Eles fornecem uma forma de resolver problemas de design de software de forma elegante e eficiente. Exemplo: Singleton, Factory, Observer.</li>
                </ul>
                <h3>Importância:</h3>
                <ul>
                    <li><strong>Reuso:</strong> Permitem reutilizar soluções testadas e comprovadas, economizando tempo e esforço.</li>
                    <li><strong>Organização:</strong> Promovem uma estrutura clara e organizada para o código, facilitando a compreensão e a manutenção.</li>
                    <li><strong>Manutenção:</strong> Sistemas construídos com padrões são mais fáceis de manter e estender, pois seguem convenções conhecidas.</li>
                    <li><strong>Comunicação:</strong> Fornecem um vocabulário comum entre desenvolvedores, facilitando a comunicação sobre o design do sistema.</li>
                </ul>
                <h3>Diferença entre Padrão Arquitetural e Padrão de Projeto:</h3>
                <p>A principal diferença reside no nível de abstração. Padrões arquiteturais definem a estrutura macro do sistema, enquanto padrões de projeto focam na microestrutura, ou seja, no design de classes e objetos dentro de um componente.</p>
            </div>
            <div class="slide-footer">
                <div class="slide-number">3</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 4: Princípios SOLID (S e O) -->
    <div class="slide" id="slide-4">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Princípios SOLID Completos</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>SOLID é um acrônimo para cinco princípios de design de software que visam tornar os designs de software mais compreensíveis, flexíveis e manuteníveis.</p>
                <h3>S - Single Responsibility Principle (SRP) - Princípio da Responsabilidade Única:</h3>
                <p>Um módulo (classe, função, etc.) deve ter apenas uma razão para mudar, ou seja, deve ter apenas uma responsabilidade. Isso significa que cada módulo deve ser responsável por uma única parte da funcionalidade do software.</p>
                <pre><code class="language-javascript">
// Exemplo RUIM: Uma classe que gerencia usuários e envia e-mails
class UserHandler {
    createUser(user) { /* ... */ }
    sendWelcomeEmail(user) { /* ... */ }
}

// Exemplo BOM: Separação de responsabilidades
class UserManager {
    createUser(user) { /* ... */ }
}

class EmailService {
    sendWelcomeEmail(user) { /* ... */ }
}
                </code></pre>
                <h3>O - Open/Closed Principle (OCP) - Princípio Aberto/Fechado:</h3>
                <p>Entidades de software (classes, módulos, funções, etc.) devem ser abertas para extensão, mas fechadas para modificação. Isso significa que o comportamento de um módulo pode ser estendido sem a necessidade de modificar seu código-fonte existente.</p>
                <pre><code class="language-javascript">
// Exemplo RUIM: Adicionar novo tipo de relatório exige modificar a função
function generateReport(type) {
    if (type === 'PDF') { /* ... */ }
    else if (type === 'CSV') { /* ... */ }
}

// Exemplo BOM: Usando polimorfismo para extensão
class ReportGenerator {
    generate() { throw new Error('Method not implemented'); }
}

class PdfReportGenerator extends ReportGenerator {
    generate() { /* Gerar PDF */ }
}

class CsvReportGenerator extends ReportGenerator {
    generate() { /* Gerar CSV */ }
}

function generate(reportGenerator) {
    reportGenerator.generate();
}
                </code></pre>
                <h3>L - Liskov Substitution Principle (LSP) - Princípio da Substituição de Liskov:</h3>
                <p>Objetos de um programa devem ser substituíveis por instâncias de seus subtipos sem alterar a corretude do programa. Isso significa que uma classe derivada deve ser capaz de ser usada no lugar de sua classe base sem quebrar a aplicação.</p>
                <pre><code class="language-javascript">
// Exemplo RUIM: Quadrado não é um retângulo perfeito
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    setWidth(width) { this.width = width; }
    setHeight(height) { this.height = height; }
    getArea() { return this.width * this.height; }
}

class Square extends Rectangle {
    constructor(size) {
        super(size, size);
    }
    setWidth(width) { this.width = this.height = width; }
    setHeight(height) { this.width = this.height = height; }
}

function increaseRectangleWidth(rectangle) {
    rectangle.setWidth(rectangle.width + 1);
}

let rect = new Rectangle(10, 5);
increaseRectangleWidth(rect); // rect.width = 11, rect.height = 5

let square = new Square(10);
increaseRectangleWidth(square); // square.width = 11, square.height = 11 (quebra a expectativa)

// Exemplo BOM: Interfaces ou classes base que definem contratos claros
class Shape {
    getArea() { throw new Error("Method not implemented"); }
}

class Rect extends Shape {
    constructor(width, height) {
        super();
        this.width = width;
        this.height = height;
    }
    getArea() { return this.width * this.height; }
}

class Sq extends Shape {
    constructor(size) {
        super();
        this.size = size;
    }
    getArea() { return this.size * this.size; }
}
                </code></pre>
                <h3>I - Interface Segregation Principle (ISP) - Princípio da Segregação de Interfaces:</h3>
                <p>Clientes não devem ser forçados a depender de interfaces que não utilizam. Isso significa que interfaces grandes e monolíticas devem ser divididas em interfaces menores e mais específicas, de modo que os clientes só precisem implementar os métodos que realmente lhes interessam.</p>
                <pre><code class="language-javascript">
// Exemplo RUIM: Interface grande e genérica
class Worker {
    work() { throw new Error("Method not implemented"); }
    eat() { throw new Error("Method not implemented"); }
    sleep() { throw new Error("Method not implemented"); }
}

class HumanWorker extends Worker {
    work() { console.log("Human working"); }
    eat() { console.log("Human eating"); }
    sleep() { console.log("Human sleeping"); }
}

class RobotWorker extends Worker {
    work() { console.log("Robot working"); }
    eat() { /* Robôs não comem, mas são forçados a implementar */ }
    sleep() { /* Robôs não dormem, mas são forçados a implementar */ }
}

// Exemplo BOM: Interfaces segregadas
class Workable {
    work() { throw new Error("Method not implemented"); }
}

class Eatable {
    eat() { throw new Error("Method not implemented"); }
}

class Sleepable {
    sleep() { throw new Error("Method not implemented"); }
}

class HumanWorkerISP extends Workable implements Eatable, Sleepable {
    work() { console.log("Human working"); }
    eat() { console.log("Human eating"); }
    sleep() { console.log("Human sleeping"); }
}

class RobotWorkerISP extends Workable {
    work() { console.log("Robot working"); }
}
                </code></pre>
                <h3>D - Dependency Inversion Principle (DIP) - Princípio da Inversão de Dependência:</h3>
                <p>Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações. Abstrações não devem depender de detalhes. Detalhes devem depender de abstrações. Isso promove o desacoplamento entre os módulos, tornando o sistema mais flexível e testável.</p>
                <pre><code class="language-javascript">
// Exemplo RUIM: Módulo de alto nível (ReportGenerator) depende de módulo de baixo nível (MySQLDatabase)
class MySQLDatabase {
    getData() { console.log("Getting data from MySQL"); return [1, 2, 3]; }
}

class ReportGeneratorDIP {
    constructor() {
        this.database = new MySQLDatabase();
    }
    generateReport() {
        const data = this.database.getData();
        console.log("Generating report with data:", data);
    }
}

// Exemplo BOM: Dependência de abstrações
class Database {
    getData() { throw new Error("Method not implemented"); }
}

class MySQLDatabaseDIP extends Database {
    getData() { console.log("Getting data from MySQL"); return [1, 2, 3]; }
}

class MongoDBDatabaseDIP extends Database {
    getData() { console.log("Getting data from MongoDB"); return [4, 5, 6]; }
}

class ReportGeneratorDIPCorrect {
    constructor(database) {
        this.database = database;
    }
    generateReport() {
        const data = this.database.getData();
        console.log("Generating report with data:", data);
    }
}

const mysqlDb = new MySQLDatabaseDIP();
const mongoDb = new MongoDBDatabaseDIP();

const report1 = new ReportGeneratorDIPCorrect(mysqlDb);
report1.generateReport();

const report2 = new ReportGeneratorDIPCorrect(mongoDb);
report2.generateReport();
                </code></pre>
            </div>
            <div class="slide-footer">
                <div class="slide-number">4</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 5: Arquitetura MVC aplicada ao backend -->
    <div class="slide" id="slide-5">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Arquitetura MVC aplicada ao backend</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>O padrão arquitetural Model-View-Controller (MVC) é amplamente utilizado no desenvolvimento de aplicações web para separar as preocupações em três componentes principais.</p>
                <h3>Conceito e Estrutura:</h3>
                <ul>
                    <li><strong>Model (Modelo):</strong> Representa os dados e a lógica de negócios da aplicação. É responsável por gerenciar o estado dos dados, as regras de negócio e a interação com o banco de dados. O Model é independente da interface do usuário.</li>
                    <li><strong>View (Visão):</strong> Responsável pela apresentação dos dados ao usuário. No contexto de backend, a 


View geralmente não existe como uma interface gráfica, mas sim como a formatação da resposta (JSON, XML) que será enviada ao cliente. Pode ser um serializador de dados.
                    <li><strong>Controller (Controlador):</strong> Atua como um intermediário entre o Model e a View. Ele recebe as requisições do usuário, processa-as (interagindo com o Model para obter ou manipular dados) e, em seguida, seleciona a View apropriada para apresentar a resposta.</li>
                </ul>
                <p>No backend, o MVC ajuda a organizar o código de forma lógica, tornando-o mais fácil de entender, testar e manter. A separação de preocupações garante que as alterações em uma parte da aplicação não afetem desnecessariamente outras partes.</p>
            </div>
            <div class="slide-footer">
                <div class="slide-number">5</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 6: Implementação prática com uma API REST simples (MVC) -->
    <div class="slide" id="slide-6">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Implementação prática com uma API REST simples (MVC)</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>Vamos considerar um exemplo simples de uma API REST para gerenciar produtos, utilizando Node.js com Express para ilustrar a aplicação do MVC no backend.</p>
                <h3>Estrutura de Pastas:</h3>
                <pre><code class="language-bash">
. 
├── app.js             # Ponto de entrada da aplicação
├── controllers
│   └── productController.js
├── models
│   └── productModel.js
└── routes
    └── productRoutes.js
                </code></pre>
                <h3><code>models/productModel.js</code> (Model - Lógica de Dados)</h3>
                <pre><code class="language-javascript">
const products = []; // Simula um banco de dados

class Product {
    constructor(id, name, price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    static getAll() {
        return products;
    }

    static getById(id) {
        return products.find(p => p.id === id);
    }

    static add(product) {
        products.push(product);
        return product;
    }

    static update(id, updatedProduct) {
        const index = products.findIndex(p => p.id === id);
        if (index !== -1) {
            products[index] = { ...products[index], ...updatedProduct };
            return products[index];
        }
        return null;
    }

    static delete(id) {
        const initialLength = products.length;
        products = products.filter(p => p.id !== id);
        return products.length < initialLength;
    }
}

module.exports = Product;
                </code></pre>
            </div>
            <div class="slide-footer">
                <div class="slide-number">6</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 7: Separação de responsabilidades no MVC -->
    <div class="slide" id="slide-7">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Separação de responsabilidades no MVC</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>Continuando o exemplo da API de produtos, veja como os Controllers e as Rotas se encaixam na separação de responsabilidades.</p>
                <h3><code>controllers/productController.js</code> (Controller - Lógica de Requisição/Resposta)</h3>
                <pre><code class="language-javascript">
const Product = require("../models/productModel");

exports.getAllProducts = (req, res) => {
    res.json(Product.getAll());
};

exports.getProductById = (req, res) => {
    const product = Product.getById(parseInt(req.params.id));
    if (product) {
        res.json(product);
    } else {
        res.status(404).send("Produto não encontrado");
    }
};

exports.createProduct = (req, res) => {
    const newProduct = Product.add(req.body);
    res.status(201).json(newProduct);
};

exports.updateProduct = (req, res) => {
    const updatedProduct = Product.update(parseInt(req.params.id), req.body);
    if (updatedProduct) {
        res.json(updatedProduct);
    } else {
        res.status(404).send("Produto não encontrado");
    }
};

exports.deleteProduct = (req, res) => {
    const deleted = Product.delete(parseInt(req.params.id));
    if (deleted) {
        res.status(204).send(); // No Content
    } else {
        res.status(404).send("Produto não encontrado");
    }
};
                </code></pre>
                <h3><code>routes/productRoutes.js</code> (Rotas - Mapeamento de URLs)</h3>
                <pre><code class="language-javascript">
const express = require("express");
const router = express.Router();
const productController = require("../controllers/productController");

router.get("/", productController.getAllProducts);
router.get("/:id", productController.getProductById);
router.post("/", productController.createProduct);
router.put("/:id", productController.updateProduct);
router.delete("/:id", productController.deleteProduct);

module.exports = router;
                </code></pre>
            </div>
            <div class="slide-footer">
                <div class="slide-number">7</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 8: Manutenibilidade e Escalabilidade com MVC -->
    <div class="slide" id="slide-8">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Manutenibilidade e Escalabilidade com MVC</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>A arquitetura MVC oferece benefícios significativos para a manutenibilidade e escalabilidade de aplicações backend.</p>
                <h3>Manutenibilidade:</h3>
                <ul>
                    <li><strong>Código Organizado:</strong> A separação clara de Model, View (serialização) e Controller torna o código mais fácil de entender e navegar.</li>
                    <li><strong>Testabilidade:</strong> Cada componente pode ser testado de forma isolada, facilitando a identificação e correção de bugs.</li>
                    <li><strong>Reuso de Código:</strong> A lógica de negócios no Model pode ser reutilizada em diferentes Controllers ou até mesmo em outras aplicações.</li>
                    <li><strong>Facilidade de Debugging:</strong> Problemas podem ser rastreados mais facilmente para o componente responsável.</li>
                </ul>
                <h3>Escalabilidade:</h3>
                <ul>
                    <li><strong>Desenvolvimento Paralelo:</strong> Diferentes equipes podem trabalhar em Models, Views e Controllers simultaneamente sem grandes conflitos.</li>
                    <li><strong>Distribuição de Carga:</strong> Em sistemas distribuídos, os componentes podem ser escalados independentemente. Por exemplo, se a lógica de negócios for mais pesada, apenas os servidores que rodam o Model podem ser aumentados.</li>
                    <li><strong>Flexibilidade para Mudanças:</strong> Novas funcionalidades ou alterações em requisitos podem ser implementadas com menor impacto no sistema como um todo.</li>
                </ul>
            </div>
            <div class="slide-footer">
                <div class="slide-number">8</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 9: Documentação Técnica Essencial -->
    <div class="slide" id="slide-9">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Documentação Técnica Essencial</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>A documentação técnica é crucial para o sucesso de qualquer projeto de software. Ela serve como um guia para desenvolvedores, testadores e usuários, garantindo que todos compreendam o funcionamento do sistema.</p>
                <h3>Importância da Documentação:</h3>
                <ul>
                    <li><strong>Compreensão do Sistema:</strong> Ajuda novos membros da equipe a entenderem rapidamente a arquitetura e o funcionamento do software.</li>
                    <li><strong>Manutenção e Evolução:</strong> Facilita a manutenção, depuração e a adição de novas funcionalidades ao longo do tempo.</li>
                    <li><strong>Colaboração:</strong> Promove uma comunicação clara e eficaz entre os membros da equipe e stakeholders.</li>
                    <li><strong>Garantia de Qualidade:</strong> Serve como base para a criação de planos de teste e validação do sistema.</li>
                </ul>
                <h3>Introdução à UML (Unified Modeling Language):</h3>
                <p>A UML é uma linguagem de modelagem visual padronizada para especificar, visualizar, construir e documentar os artefatos de um sistema de software. Ela oferece diversos tipos de diagramas para representar diferentes aspectos do sistema.</p>
            </div>
            <div class="slide-footer">
                <div class="slide-number">9</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 10: Diagrama de Caso de Uso -->
    <div class="slide" id="slide-10">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Diagrama de Caso de Uso</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>O Diagrama de Caso de Uso descreve a funcionalidade de um sistema do ponto de vista do usuário (ator). Ele mostra o que o sistema faz, mas não como ele faz.</p>
                <h3>O que é?</h3>
                <ul>
                    <li>Representa as interações entre os usuários (atores) e o sistema.</li>
                    <li>Foca nos requisitos funcionais do sistema.</li>
                </ul>
                <h3>Para que serve?</h3>
                <ul>
                    <li>Capturar e organizar os requisitos funcionais.</li>
                    <li>Comunicar a funcionalidade do sistema para stakeholders não técnicos.</li>
                    <li>Definir o escopo do sistema.</li>
                </ul>
                <h3>Elementos Principais:</h3>
                <ul>
                    <li><strong>Ator:</strong> Representa um usuário, outro sistema ou qualquer entidade externa que interage com o sistema.</li>
                    <li><strong>Caso de Uso:</strong> Representa uma funcionalidade específica que o sistema oferece.</li>
                    <li><strong>Relacionamentos:</strong> Incluem associação (ator com caso de uso), inclusão (um caso de uso inclui outro), extensão (um caso de uso estende outro) e generalização.</li>
                </ul>
                <h3>Exemplo Prático: Sistema de E-commerce</h3>
                <pre><code class="language-uml">
@startuml
left to right direction
actor Cliente
actor Administrador

rectangle "Sistema de E-commerce" {
  usecase "Fazer Login" as UC1
  usecase "Pesquisar Produto" as UC2
  usecase "Adicionar Produto ao Carrinho" as UC3
  usecase "Realizar Pagamento" as UC4
  usecase "Visualizar Histórico de Pedidos" as UC5
  usecase "Gerenciar Produtos" as UC6
  usecase "Gerenciar Usuários" as UC7
}

Cliente -- UC1
Cliente -- UC2
Cliente -- UC3
Cliente -- UC4
Cliente -- UC5

Administrador -- UC1
Administrador -- UC6
Administrador -- UC7

UC4 .> (UC1) : include
UC6 .> (UC1) : include
UC7 .> (UC1) : include
@enduml
                </code></pre>
            </div>
            <div class="slide-footer">
                <div class="slide-number">10</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 11: Diagrama de Classes -->
    <div class="slide" id="slide-11">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Diagrama de Classes</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>O Diagrama de Classes é o diagrama mais comum na UML e é fundamental para a modelagem orientada a objetos. Ele descreve a estrutura estática de um sistema, mostrando suas classes, atributos, operações e os relacionamentos entre elas.</p>
                <h3>O que é?</h3>
                <ul>
                    <li>Representa as classes de um sistema e como elas se relacionam.</li>
                    <li>Foca na estrutura do sistema.</li>
                </ul>
                <h3>Para que serve?</h3>
                <ul>
                    <li>Visualizar a estrutura de um sistema.</li>
                    <li>Compreender as relações entre diferentes partes do código.</li>
                    <li>Facilitar o design e a implementação de novas funcionalidades.</li>
                </ul>
                <h3>Elementos Principais:</h3>
                <ul>
                    <li><strong>Classe:</strong> Representa um conjunto de objetos com características (atributos) e comportamentos (operações) semelhantes.</li>
                    <li><strong>Atributos:</strong> Propriedades que descrevem o estado de um objeto.</li>
                    <li><strong>Operações (Métodos):</strong> Comportamentos que um objeto pode realizar.</li>
                    <li><strong>Relacionamentos:</strong>
                        <ul>
                            <li><strong>Associação:</strong> Conexão entre classes.</li>
                            <li><strong>Agregação:</strong> Um tipo de associação que representa um relacionamento "todo-parte" onde a parte pode existir independentemente do todo.</li>
                            <li><strong>Composição:</strong> Um tipo forte de agregação onde a parte não pode existir sem o todo.</li>
                            <li><strong>Generalização (Herança):</strong> Representa um relacionamento "é um tipo de".</li>
                            <li><strong>Dependência:</strong> Uma classe depende de outra.</li>
                        </ul>
                    </li>
                </ul>
                <h3>Exemplo Prático: Sistema de Biblioteca</h3>
                <pre><code class="language-uml">
@startuml
class Livro {
  -titulo: String
  -autor: String
  -isbn: String
  +getTitulo(): String
  +getAutor(): String
}

class Membro {
  -nome: String
  -idMembro: String
  +getNome(): String
}

class Emprestimo {
  -dataEmprestimo: Date
  -dataDevolucao: Date
  +getDataEmprestimo(): Date
}

Livro "1" -- "*" Emprestimo : "contém"
Membro "1" -- "*" Emprestimo : "realiza"
@enduml
                </code></pre>
            </div>
            <div class="slide-footer">
                <div class="slide-number">11</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 12: Diagrama de Sequência -->
    <div class="slide" id="slide-12">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Diagrama de Sequência</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>O Diagrama de Sequência mostra a ordem cronológica das interações entre objetos em um cenário específico. Ele é excelente para visualizar o fluxo de controle e a troca de mensagens entre os objetos.</p>
                <h3>O que é?</h3>
                <ul>
                    <li>Representa a interação entre objetos em uma sequência temporal.</li>
                    <li>Foca no comportamento dinâmico do sistema.</li>
                </ul>
                <h3>Para que serve?</h3>
                <ul>
                    <li>Modelar a lógica de um caso de uso ou operação.</li>
                    <li>Entender a ordem das chamadas de métodos.</li>
                    <li>Identificar gargalos ou problemas de comunicação.</li>
                </ul>
                <h3>Elementos Principais:</h3>
                <ul>
                    <li><strong>Ator:</strong> Entidade externa que inicia a sequência.</li>
                    <li><strong>Linha de Vida (Lifeline):</strong> Representa a existência de um objeto ou ator durante a interação.</li>
                    <li><strong>Mensagem:</strong> Representa a comunicação entre objetos, geralmente uma chamada de método.</li>
                    <li><strong>Ativação (Activation Bar):</strong> Indica o período em que um objeto está executando uma ação.</li>
                </ul>
                <h3>Exemplo Prático: Login de Usuário</h3>
                <pre><code class="language-uml">
@startuml
actor Usuário
participant "Interface de Login" as UI
participant "Controlador de Autenticação" as AuthController
participant "Serviço de Usuário" as UserService
participant "Banco de Dados" as DB

Usuário -> UI: Digita credenciais
UI -> AuthController: autenticar(username, password)
AuthController -> UserService: validarCredenciais(username, password)
UserService -> DB: buscarUsuario(username)
DB --> UserService: retorna dados do usuário
UserService --> AuthController: retorna resultado da validação

alt Credenciais Válidas
    AuthController --> UI: sucessoLogin()
    UI --> Usuário: Exibe tela principal
else Credenciais Inválidas
    AuthController --> UI: erroLogin()
    UI --> Usuário: Exibe mensagem de erro
end
@enduml
                </code></pre>
            </div>
            <div class="slide-footer">
                <div class="slide-number">12</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <!-- Slide 13: Conclusão -->
    <div class="slide" id="slide-13">
        <div class="slide-content">
            <div class="slide-header">
                <div class="logo-container">
                    <h2>Conclusão</h2>
                    <!-- Placeholder for logo image -->
                    <img src="images/logoBFD.webp" alt="Logo Bolsa Futuro Digital" class="bfd-logo">
                </div>
            </div>
            <div class="slide-body">
                <p>Nesta aula, exploramos a importância dos padrões de desenvolvimento de software, a aplicação da arquitetura MVC no backend e a relevância da documentação técnica com diagramas UML.</p>
                <h3>Resumo dos Tópicos:</h3>
                <ul>
                    <li>Padrões de desenvolvimento (arquiteturais e de projeto) são soluções reutilizáveis para problemas comuns.</li>
                    <li>Os princípios SOLID (SRP e OCP) promovem código mais limpo e manutenível.</li>
                    <li>A arquitetura MVC organiza o backend em Model, View e Controller, melhorando a manutenibilidade e escalabilidade.</li>
                    <li>A documentação técnica, especialmente com UML (Caso de Uso, Classes, Sequência), é vital para a compreensão e evolução do sistema.</li>
                </ul>
                <h3>Próximos Passos:</h3>
                <ul>
                    <li>Pratique a aplicação dos padrões de projeto em seus próprios projetos.</li>
                    <li>Explore outros princípios SOLID e padrões de projeto.</li>
                    <li>Desenvolva APIs RESTful utilizando a arquitetura MVC.</li>
                    <li>Crie diagramas UML para documentar seus sistemas.</li>
                </ul>
                <blockquote>"Aprender padrões é como aprender um novo idioma. Uma vez que você o domina, pode expressar ideias mais complexas e elegantes."</blockquote>
            </div>
            <div class="slide-footer">
                <div class="slide-number">13</div>
                <div>Programa de Formação Acelerada</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="prevBtn">Anterior</button>
        <button id="nextBtn">Próximo</button>
        <button id="printBtn">Imprimir / PDF</button>
    </div>

    <script>
        const slides = document.querySelectorAll(".slide");
        let currentSlide = 0;

        function showSlide(index) {
            slides.forEach((slide, i) => {
                slide.classList.remove("active");
                if (i === index) {
                    slide.classList.add("active");
                }
            });
            updateSlideNumber();
        }

        function nextSlide() {
            currentSlide = (currentSlide + 1) % slides.length;
            showSlide(currentSlide);
        }

        function prevSlide() {
            currentSlide = (currentSlide - 1 + slides.length) % slides.length;
            showSlide(currentSlide);
        }

        function updateSlideNumber() {
            const slideNumberElement = document.querySelector(".slide-number");
            if (slideNumberElement) {
                slideNumberElement.textContent = currentSlide + 1;
            }
        }

        document.getElementById("nextBtn").addEventListener("click", nextSlide);
        document.getElementById("prevBtn").addEventListener("click", prevSlide);
        document.getElementById("printBtn").addEventListener("click", function() { window.print(); });

        // Initialize first slide
        showSlide(currentSlide);
    </script>
</body>
</html>

